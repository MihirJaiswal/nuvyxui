{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "water-ripple-effect",
  "type": "registry:ui",
  "title": "Water Ripple Effect",
  "description": "A water ripple effect that that provide several effects.",
  "dependencies": [
    "three",
    "three"
  ],
  "files": [
    {
      "path": "registry/ui/water-ripple-effect.tsx",
      "content": "\"use client\"\r\n\r\nimport { useRef, useEffect } from \"react\"\r\nimport * as THREE from \"three\"\r\n\r\ninterface WaterRippleEffectProps {\r\n  imageSrc: string\r\n  width?: number\r\n  height?: number\r\n  waveIntensity?: number\r\n  rippleIntensity?: number\r\n  animationSpeed?: number\r\n  hoverRippleMultiplier?: number\r\n  transitionSpeed?: number\r\n  className?: string\r\n  containerClassName?: string\r\n  scale?: number\r\n  waveFrequency?: number\r\n  rippleFrequency?: number\r\n  distortionAmount?: number\r\n  onHover?: () => void\r\n  onLeave?: () => void\r\n}\r\n\r\nexport default function WaterRippleEffect({\r\n  imageSrc,\r\n  width = 920,\r\n  height = 955,\r\n  waveIntensity = 0.006,\r\n  rippleIntensity = 0.012,\r\n  animationSpeed = 1.0,\r\n  hoverRippleMultiplier = 4.0,\r\n  transitionSpeed = 0.08,\r\n  className = \"\",\r\n  containerClassName = \"\",\r\n  scale = 1.0,\r\n  waveFrequency = 10.0,\r\n  rippleFrequency = 20.0,\r\n  distortionAmount = 0.008,\r\n  onHover,\r\n  onLeave,\r\n  ...props\r\n}: WaterRippleEffectProps & React.HTMLAttributes<HTMLDivElement>) {\r\n  const mountRef = useRef<HTMLDivElement>(null)\r\n  const sceneRef = useRef<THREE.Scene | null>(null)\r\n  const rendererRef = useRef<THREE.WebGLRenderer | null>(null)\r\n  const materialRef = useRef<THREE.ShaderMaterial | null>(null)\r\n  const mouseRef = useRef({ x: 0.5, y: 0.5 })\r\n  const timeRef = useRef(0)\r\n  const isHoveredRef = useRef(false)\r\n\r\n  useEffect(() => {\r\n    const mountElement = mountRef.current\r\n    if (!mountElement) return\r\n    const scene = new THREE.Scene()\r\n    const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000)\r\n    const renderer = new THREE.WebGLRenderer({ \r\n      antialias: true, \r\n      alpha: true,\r\n      powerPreference: \"high-performance\",\r\n      precision: \"highp\"\r\n    })\r\n\r\n    renderer.setSize(width, height)\r\n    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)) \r\n    renderer.setClearColor(0x000000, 0)\r\n    mountElement.appendChild(renderer.domElement)\r\n    const textureLoader = new THREE.TextureLoader()\r\n    const texture = textureLoader.load(imageSrc, (loadedTexture) => {\r\n      loadedTexture.magFilter = THREE.LinearFilter\r\n      loadedTexture.minFilter = THREE.LinearMipmapLinearFilter\r\n      loadedTexture.wrapS = THREE.ClampToEdgeWrapping\r\n      loadedTexture.wrapT = THREE.ClampToEdgeWrapping\r\n      loadedTexture.generateMipmaps = true\r\n      loadedTexture.needsUpdate = true\r\n    })\r\n\r\n    const vertexShader = `\r\n      varying vec2 vUv;\r\n      varying vec2 vPosition;\r\n\r\n      void main() {\r\n        vUv = uv;\r\n        vPosition = position.xy;\r\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n      }\r\n    `\r\n\r\n    const fragmentShader = `\r\n      uniform sampler2D texture1;\r\n      uniform float time;\r\n      uniform vec2 mouse;\r\n      uniform float hoverIntensity;\r\n      uniform float waveIntensity;\r\n      uniform float rippleIntensity;\r\n      uniform float animationSpeed;\r\n      uniform float waveFrequency;\r\n      uniform float rippleFrequency;\r\n      uniform float distortionAmount;\r\n      varying vec2 vUv;\r\n      varying vec2 vPosition;\r\n\r\n      // Improved smoothstep for better interpolation\r\n      float smoothwave(float x) {\r\n        return sin(x) * 0.5 + 0.5;\r\n      }\r\n\r\n      void main() {\r\n        vec2 uv = vUv;\r\n        \r\n        // Reduced intensity for global waves to preserve image quality\r\n        float waveScale = waveIntensity * 0.5; // Reduce default intensity\r\n        \r\n        // More subtle global wavy distortion\r\n        float wave1 = sin(uv.x * waveFrequency + time * animationSpeed * 2.0) * waveScale;\r\n        float wave2 = sin(uv.y * (waveFrequency * 0.8) + time * animationSpeed * 1.5) * (waveScale * 0.8);\r\n        float wave3 = sin((uv.x + uv.y) * (waveFrequency * 1.2) + time * animationSpeed * 2.5) * (waveScale * 0.3);\r\n        \r\n        // Mouse-based ripples with falloff\r\n        float dist = distance(uv, mouse);\r\n        float rippleScale = rippleIntensity * 0.7; // Reduce ripple intensity\r\n        \r\n        // Improved falloff function for smoother transitions\r\n        float falloff = exp(-dist * 4.0);\r\n        \r\n        float mouseWave1 = sin(dist * rippleFrequency - time * animationSpeed * 4.0) * \r\n                          falloff * hoverIntensity * rippleScale;\r\n        float mouseWave2 = sin(dist * (rippleFrequency * 0.75) - time * animationSpeed * 3.0) * \r\n                          falloff * hoverIntensity * (rippleScale * 0.6);\r\n        \r\n        // More controlled expanding ripples\r\n        float ripple1 = sin(length(uv - mouse) * (rippleFrequency * 1.25) - time * animationSpeed * 5.0) * \r\n                       exp(-length(uv - mouse) * 5.0) * hoverIntensity * (rippleScale * 0.8);\r\n        float ripple2 = sin(length(uv - mouse) * (rippleFrequency * 0.9) - time * animationSpeed * 3.5) * \r\n                       exp(-length(uv - mouse) * 4.0) * hoverIntensity * (rippleScale * 0.6);\r\n        \r\n        // Combine waves with reduced intensity\r\n        float totalWave = (wave1 + wave2 + wave3 + mouseWave1 + mouseWave2 + ripple1 + ripple2) * 0.5;\r\n        \r\n        // More subtle distortion\r\n        float distortScale = distortionAmount * 0.6;\r\n        vec2 distortion = vec2(\r\n          sin(uv.x * (waveFrequency * 0.8) + time * animationSpeed * 1.8) * distortScale * 0.4 + \r\n          sin(uv.y * (waveFrequency * 0.6) + time * animationSpeed * 2.2) * distortScale * 0.3,\r\n          sin(uv.y * (waveFrequency * 0.7) + time * animationSpeed * 1.6) * distortScale * 0.4 + \r\n          sin(uv.x * (waveFrequency * 0.9) + time * animationSpeed * 2.0) * distortScale * 0.3\r\n        );\r\n        \r\n        // Reduced mouse-based radial distortion\r\n        vec2 mouseDir = uv - mouse;\r\n        float mouseDist = length(mouseDir);\r\n        vec2 mouseDistortion = normalize(mouseDir) * sin(mouseDist * rippleFrequency - time * animationSpeed * 4.0) * \r\n                              exp(-mouseDist * 4.0) * hoverIntensity * distortScale * 0.5;\r\n        \r\n        // Combine distortions with reduced intensity\r\n        vec2 finalDistortion = (distortion + mouseDistortion) * 0.7 + vec2(totalWave * 0.2, totalWave * 0.2);\r\n        \r\n        // Apply distortion to UV coordinates\r\n        vec2 distortedUv = uv + finalDistortion;\r\n        \r\n        // Clamp UV coordinates to prevent sampling outside texture bounds\r\n        distortedUv = clamp(distortedUv, 0.0, 1.0);\r\n        \r\n        // Sample texture with distorted coordinates\r\n        vec4 color = texture2D(texture1, distortedUv);\r\n        \r\n        gl_FragColor = color;\r\n      }\r\n    `\r\n    const material = new THREE.ShaderMaterial({\r\n      uniforms: {\r\n        texture1: { value: texture },\r\n        time: { value: 0 },\r\n        mouse: { value: new THREE.Vector2(0.5, 0.5) },\r\n        hoverIntensity: { value: 0.3 },\r\n        waveIntensity: { value: waveIntensity },\r\n        rippleIntensity: { value: rippleIntensity },\r\n        animationSpeed: { value: animationSpeed },\r\n        waveFrequency: { value: waveFrequency },\r\n        rippleFrequency: { value: rippleFrequency },\r\n        distortionAmount: { value: distortionAmount }\r\n      },\r\n      vertexShader,\r\n      fragmentShader,\r\n      transparent: true,\r\n    })\r\n\r\n    const aspectRatio = width / height\r\n    const geometry = new THREE.PlaneGeometry(4 * aspectRatio, 4, 64, 64) \r\n    const mesh = new THREE.Mesh(geometry, material)\r\n    scene.add(mesh)\r\n\r\n    camera.position.z = 3\r\n    sceneRef.current = scene\r\n    rendererRef.current = renderer\r\n    materialRef.current = material\r\n\r\n    // Event handlers\r\n    const handleMouseMove = (event: MouseEvent) => {\r\n      const rect = renderer.domElement.getBoundingClientRect()\r\n      const x = (event.clientX - rect.left) / rect.width\r\n      const y = 1 - (event.clientY - rect.top) / rect.height\r\n      mouseRef.current = { x, y }\r\n    }\r\n\r\n    const handleMouseEnter = () => {\r\n      isHoveredRef.current = true\r\n      onHover?.()\r\n    }\r\n    \r\n    const handleMouseLeave = () => {\r\n      isHoveredRef.current = false\r\n      onLeave?.()\r\n    }\r\n\r\n    renderer.domElement.addEventListener(\"mousemove\", handleMouseMove)\r\n    renderer.domElement.addEventListener(\"mouseenter\", handleMouseEnter)\r\n    renderer.domElement.addEventListener(\"mouseleave\", handleMouseLeave)\r\n\r\n    const animate = () => {\r\n      timeRef.current += 0.016\r\n\r\n      if (materialRef.current) {\r\n        materialRef.current.uniforms.time.value = timeRef.current\r\n        materialRef.current.uniforms.mouse.value.set(mouseRef.current.x, mouseRef.current.y)\r\n        const targetIntensity = isHoveredRef.current ? hoverRippleMultiplier : 0.3\r\n        const currentIntensity = materialRef.current.uniforms.hoverIntensity.value\r\n        materialRef.current.uniforms.hoverIntensity.value += (targetIntensity - currentIntensity) * transitionSpeed\r\n      }\r\n\r\n      if (rendererRef.current && sceneRef.current) {\r\n        rendererRef.current.render(sceneRef.current, camera)\r\n      }\r\n      requestAnimationFrame(animate)\r\n    }\r\n    animate()\r\n\r\n    // Cleanup\r\n    return () => {\r\n      renderer.domElement.removeEventListener(\"mousemove\", handleMouseMove)\r\n      renderer.domElement.removeEventListener(\"mouseenter\", handleMouseEnter)\r\n      renderer.domElement.removeEventListener(\"mouseleave\", handleMouseLeave)\r\n\r\n      if (mountElement && renderer.domElement && mountElement.contains(renderer.domElement)) {\r\n        mountElement.removeChild(renderer.domElement)\r\n      }\r\n      renderer.dispose()\r\n      geometry.dispose()\r\n      material.dispose()\r\n      texture.dispose()\r\n    }\r\n  }, [\r\n    imageSrc, width, height, waveIntensity, rippleIntensity, animationSpeed, hoverRippleMultiplier, transitionSpeed,\r\n    waveFrequency, rippleFrequency, distortionAmount, onHover, onLeave\r\n  ])\r\n\r\n  return (\r\n    <div className={`w-full flex justify-center items-center ${containerClassName}`}>\r\n      <div className=\"relative\">\r\n        <div\r\n          ref={mountRef}\r\n          className={`transition-transform duration-300 ${className}`}\r\n          style={{ transform: `scale(${scale})` }}\r\n        />\r\n      </div>\r\n    </div>\r\n  )\r\n}",
      "type": "registry:ui",
      "target": "components/ui/water-ripple-effect.tsx"
    }
  ]
}