{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "marquee",
  "type": "registry:ui",
  "title": "Marquee",
  "description": "A customizable, interactive scrolling marquee component.",
  "dependencies": [
    "motion",
    "clsx",
    "tailwind-merge",
    "framer-motion"
  ],
  "files": [
    {
      "path": "src/nuvyxui/components/marquee.tsx",
      "content": "\"use client\";\nimport { cn } from \"@/lib/utils\";\nimport { useMotionValue, animate, motion } from \"framer-motion\";\nimport { useState, useEffect, useRef } from \"react\";\n\nexport type MarqueeProps = {\n  children: React.ReactNode;\n  gap?: number;\n  speed?: number;\n  speedOnHover?: number;\n  direction?: \"horizontal\" | \"vertical\";\n  reverse?: boolean;\n  className?: string;\n  fadeEdges?: boolean;\n  fadeWidth?: number;\n  pauseOnTap?: boolean;\n  draggable?: boolean;\n};\n\nexport function Marquee({\n  children,\n  gap = 16,\n  speed = 100,\n  speedOnHover,\n  direction = \"horizontal\",\n  reverse = false,\n  className,\n  fadeEdges = false,\n  fadeWidth = 64,\n  pauseOnTap = true,\n  draggable = true,\n}: MarqueeProps) {\n  const [currentSpeed, setCurrentSpeed] = useState(speed);\n  const [isPaused, setIsPaused] = useState(false);\n  const [isDragging, setIsDragging] = useState(false);\n  const containerRef = useRef<HTMLDivElement>(null);\n  const translation = useMotionValue(0);\n  const [isTransitioning, setIsTransitioning] = useState(false);\n  const [key, setKey] = useState(0);\n  const dragStartPosition = useRef(0);\n  const [dimensions, setDimensions] = useState({ width: 0, height: 0 });\n\n  useEffect(() => {\n    if (!containerRef.current) return;\n\n    const currentRef = containerRef.current;\n\n    const updateDimensions = () => {\n      if (currentRef) {\n        const rect = currentRef.getBoundingClientRect();\n        setDimensions({\n          width: rect.width,\n          height: rect.height,\n        });\n      }\n    };\n\n    updateDimensions();\n\n    const resizeObserver = new ResizeObserver(updateDimensions);\n    resizeObserver.observe(currentRef);\n\n    return () => {\n      resizeObserver.unobserve(currentRef);\n      resizeObserver.disconnect();\n    };\n  }, []);\n\n  const { width, height } = dimensions;\n\n  useEffect(() => {\n    let controls;\n\n    if (isPaused || isDragging || (!width && !height)) {\n      return () => {};\n    }\n\n    const size = direction === \"horizontal\" ? width : height;\n    const contentSize = size + gap;\n\n    if (!size) return () => {};\n\n    const from = reverse ? -contentSize / 2 : 0;\n    const to = reverse ? 0 : -contentSize / 2;\n    const distanceToTravel = Math.abs(to - from);\n    const duration = distanceToTravel / currentSpeed;\n\n    if (isTransitioning) {\n      const remainingDistance = Math.abs(translation.get() - to);\n      const transitionDuration = remainingDistance / currentSpeed;\n\n      controls = animate(translation, [translation.get(), to], {\n        ease: \"linear\",\n        duration: transitionDuration,\n        onComplete: () => {\n          setIsTransitioning(false);\n          setKey((prevKey) => prevKey + 1);\n        },\n      });\n    } else {\n      controls = animate(translation, [from, to], {\n        ease: \"linear\",\n        duration: duration,\n        repeat: Infinity,\n        repeatType: \"loop\",\n        repeatDelay: 0,\n        onRepeat: () => {\n          translation.set(from);\n        },\n      });\n    }\n\n    return controls?.stop;\n  }, [\n    key,\n    translation,\n    currentSpeed,\n    width,\n    height,\n    gap,\n    isTransitioning,\n    direction,\n    reverse,\n    isPaused,\n    isDragging,\n  ]);\n\n  const fadeGradientStyles = (() => {\n    if (!fadeEdges) return {};\n\n    const size = direction === \"horizontal\" ? width : height;\n    if (size === 0) return {};\n\n    const fadePercentage = Math.min(100, Math.round((fadeWidth / size) * 100));\n\n    if (direction === \"horizontal\") {\n      return {\n        maskImage: `linear-gradient(to right, transparent, black ${fadePercentage}%, black ${\n          100 - fadePercentage\n        }%, transparent 100%)`,\n        WebkitMaskImage: `linear-gradient(to right, transparent, black ${fadePercentage}%, black ${\n          100 - fadePercentage\n        }%, transparent 100%)`,\n      };\n    } else {\n      return {\n        maskImage: `linear-gradient(to bottom, transparent, black ${fadePercentage}%, black ${\n          100 - fadePercentage\n        }%, transparent 100%)`,\n        WebkitMaskImage: `linear-gradient(to bottom, transparent, black ${fadePercentage}%, black ${\n          100 - fadePercentage\n        }%, transparent 100%)`,\n      };\n    }\n  })();\n\n  const handleTap = () => {\n    if (pauseOnTap && !isDragging) {\n      setIsPaused(!isPaused);\n      setIsTransitioning(true);\n      setKey((prevKey) => prevKey + 1);\n    }\n  };\n\n  const hoverProps = speedOnHover\n    ? {\n        onHoverStart: () => {\n          setIsTransitioning(true);\n          setCurrentSpeed(speedOnHover);\n        },\n        onHoverEnd: () => {\n          setIsTransitioning(true);\n          setCurrentSpeed(speed);\n        },\n      }\n    : {};\n\n  const handleDragStart = () => {\n    if (!draggable) return;\n\n    setIsDragging(true);\n    dragStartPosition.current = translation.get();\n  };\n\n  const handleDragEnd = () => {\n    if (!draggable) return;\n\n    setIsDragging(false);\n    setIsTransitioning(true);\n    setKey((prevKey) => prevKey + 1);\n  };\n\n  const dragConstraints = (() => {\n    const contentSize = direction === \"horizontal\" ? width : height;\n\n    return {\n      left: -contentSize,\n      right: contentSize,\n      top: -contentSize,\n      bottom: contentSize,\n    };\n  })();\n\n  return (\n    <div\n      className={cn(\n        \"overflow-hidden relative\",\n        className,\n        (pauseOnTap || draggable) && \"cursor-pointer\",\n        isDragging && \"cursor-grabbing\",\n      )}\n      style={fadeGradientStyles}\n      onClick={handleTap}\n    >\n      <motion.div\n        className={cn(\"flex w-max\", draggable && \"cursor-grab\")}\n        style={{\n          ...(direction === \"horizontal\"\n            ? { x: translation }\n            : { y: translation }),\n          flexDirection: direction === \"horizontal\" ? \"row\" : \"column\",\n          gap: `${gap}px`,\n        }}\n        ref={containerRef}\n        {...hoverProps}\n        drag={draggable ? (direction === \"horizontal\" ? \"x\" : \"y\") : false}\n        dragConstraints={dragConstraints}\n        onDragStart={handleDragStart}\n        onDragEnd={handleDragEnd}\n        dragElastic={0.1}\n        dragMomentum={false}\n      >\n        {children}\n        {children}\n      </motion.div>\n    </div>\n  );\n}\n",
      "type": "registry:ui",
      "target": "components/ui/marquee.tsx"
    },
    {
      "path": "src\\nuvyxui\\components\\marquee.tsx",
      "content": "\"use client\";\nimport { cn } from \"@/lib/utils\";\nimport { useMotionValue, animate, motion } from \"framer-motion\";\nimport { useState, useEffect, useRef } from \"react\";\n\nexport type MarqueeProps = {\n  children: React.ReactNode;\n  gap?: number;\n  speed?: number;\n  speedOnHover?: number;\n  direction?: \"horizontal\" | \"vertical\";\n  reverse?: boolean;\n  className?: string;\n  fadeEdges?: boolean;\n  fadeWidth?: number;\n  pauseOnTap?: boolean;\n  draggable?: boolean;\n};\n\nexport function Marquee({\n  children,\n  gap = 16,\n  speed = 100,\n  speedOnHover,\n  direction = \"horizontal\",\n  reverse = false,\n  className,\n  fadeEdges = false,\n  fadeWidth = 64,\n  pauseOnTap = true,\n  draggable = true,\n}: MarqueeProps) {\n  const [currentSpeed, setCurrentSpeed] = useState(speed);\n  const [isPaused, setIsPaused] = useState(false);\n  const [isDragging, setIsDragging] = useState(false);\n  const containerRef = useRef<HTMLDivElement>(null);\n  const translation = useMotionValue(0);\n  const [isTransitioning, setIsTransitioning] = useState(false);\n  const [key, setKey] = useState(0);\n  const dragStartPosition = useRef(0);\n  const [dimensions, setDimensions] = useState({ width: 0, height: 0 });\n\n  useEffect(() => {\n    if (!containerRef.current) return;\n\n    const currentRef = containerRef.current;\n\n    const updateDimensions = () => {\n      if (currentRef) {\n        const rect = currentRef.getBoundingClientRect();\n        setDimensions({\n          width: rect.width,\n          height: rect.height,\n        });\n      }\n    };\n\n    updateDimensions();\n\n    const resizeObserver = new ResizeObserver(updateDimensions);\n    resizeObserver.observe(currentRef);\n\n    return () => {\n      resizeObserver.unobserve(currentRef);\n      resizeObserver.disconnect();\n    };\n  }, []);\n\n  const { width, height } = dimensions;\n\n  useEffect(() => {\n    let controls;\n\n    if (isPaused || isDragging || (!width && !height)) {\n      return () => {};\n    }\n\n    const size = direction === \"horizontal\" ? width : height;\n    const contentSize = size + gap;\n\n    if (!size) return () => {};\n\n    const from = reverse ? -contentSize / 2 : 0;\n    const to = reverse ? 0 : -contentSize / 2;\n    const distanceToTravel = Math.abs(to - from);\n    const duration = distanceToTravel / currentSpeed;\n\n    if (isTransitioning) {\n      const remainingDistance = Math.abs(translation.get() - to);\n      const transitionDuration = remainingDistance / currentSpeed;\n\n      controls = animate(translation, [translation.get(), to], {\n        ease: \"linear\",\n        duration: transitionDuration,\n        onComplete: () => {\n          setIsTransitioning(false);\n          setKey((prevKey) => prevKey + 1);\n        },\n      });\n    } else {\n      controls = animate(translation, [from, to], {\n        ease: \"linear\",\n        duration: duration,\n        repeat: Infinity,\n        repeatType: \"loop\",\n        repeatDelay: 0,\n        onRepeat: () => {\n          translation.set(from);\n        },\n      });\n    }\n\n    return controls?.stop;\n  }, [\n    key,\n    translation,\n    currentSpeed,\n    width,\n    height,\n    gap,\n    isTransitioning,\n    direction,\n    reverse,\n    isPaused,\n    isDragging,\n  ]);\n\n  const fadeGradientStyles = (() => {\n    if (!fadeEdges) return {};\n\n    const size = direction === \"horizontal\" ? width : height;\n    if (size === 0) return {};\n\n    const fadePercentage = Math.min(100, Math.round((fadeWidth / size) * 100));\n\n    if (direction === \"horizontal\") {\n      return {\n        maskImage: `linear-gradient(to right, transparent, black ${fadePercentage}%, black ${\n          100 - fadePercentage\n        }%, transparent 100%)`,\n        WebkitMaskImage: `linear-gradient(to right, transparent, black ${fadePercentage}%, black ${\n          100 - fadePercentage\n        }%, transparent 100%)`,\n      };\n    } else {\n      return {\n        maskImage: `linear-gradient(to bottom, transparent, black ${fadePercentage}%, black ${\n          100 - fadePercentage\n        }%, transparent 100%)`,\n        WebkitMaskImage: `linear-gradient(to bottom, transparent, black ${fadePercentage}%, black ${\n          100 - fadePercentage\n        }%, transparent 100%)`,\n      };\n    }\n  })();\n\n  const handleTap = () => {\n    if (pauseOnTap && !isDragging) {\n      setIsPaused(!isPaused);\n      setIsTransitioning(true);\n      setKey((prevKey) => prevKey + 1);\n    }\n  };\n\n  const hoverProps = speedOnHover\n    ? {\n        onHoverStart: () => {\n          setIsTransitioning(true);\n          setCurrentSpeed(speedOnHover);\n        },\n        onHoverEnd: () => {\n          setIsTransitioning(true);\n          setCurrentSpeed(speed);\n        },\n      }\n    : {};\n\n  const handleDragStart = () => {\n    if (!draggable) return;\n\n    setIsDragging(true);\n    dragStartPosition.current = translation.get();\n  };\n\n  const handleDragEnd = () => {\n    if (!draggable) return;\n\n    setIsDragging(false);\n    setIsTransitioning(true);\n    setKey((prevKey) => prevKey + 1);\n  };\n\n  const dragConstraints = (() => {\n    const contentSize = direction === \"horizontal\" ? width : height;\n\n    return {\n      left: -contentSize,\n      right: contentSize,\n      top: -contentSize,\n      bottom: contentSize,\n    };\n  })();\n\n  return (\n    <div\n      className={cn(\n        \"overflow-hidden relative\",\n        className,\n        (pauseOnTap || draggable) && \"cursor-pointer\",\n        isDragging && \"cursor-grabbing\",\n      )}\n      style={fadeGradientStyles}\n      onClick={handleTap}\n    >\n      <motion.div\n        className={cn(\"flex w-max\", draggable && \"cursor-grab\")}\n        style={{\n          ...(direction === \"horizontal\"\n            ? { x: translation }\n            : { y: translation }),\n          flexDirection: direction === \"horizontal\" ? \"row\" : \"column\",\n          gap: `${gap}px`,\n        }}\n        ref={containerRef}\n        {...hoverProps}\n        drag={draggable ? (direction === \"horizontal\" ? \"x\" : \"y\") : false}\n        dragConstraints={dragConstraints}\n        onDragStart={handleDragStart}\n        onDragEnd={handleDragEnd}\n        dragElastic={0.1}\n        dragMomentum={false}\n      >\n        {children}\n        {children}\n      </motion.div>\n    </div>\n  );\n}\n",
      "type": "registry:component",
      "target": ""
    },
    {
      "path": "src\\lib\\utils.ts",
      "content": "import clsx, { ClassValue } from \"clsx\";\nimport { Metadata } from \"next\";\nimport { twMerge } from \"tailwind-merge\";\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs));\n}\n\nexport function humanize(name: string): string {\n  return name\n    .replace(/-/g, \" \")\n    .replace(/([A-Z])/g, \" $1\")\n    .trim()\n    .split(/\\s+/)\n    .map((word) => word[0].toUpperCase() + word.substring(1).toLowerCase())\n    .join(\" \");\n}\n\nexport const truncate = (str: string | null, length: number) => {\n  if (!str || str.length <= length) return str;\n  return `${str.slice(0, length - 3)}...`;\n};\n\nexport const fetcher = (...args: Parameters<typeof fetch>) =>\n  fetch(...args).then((res) => res.json());\n\nexport const capitalize = (str: string, lower = false) =>\n  (lower ? str.toLowerCase() : str).replace(/(?:^|\\s|[\"'([{])+\\S/g, (match) =>\n    match.toUpperCase(),\n  );\n\nexport function formatDate(input: string | number): string {\n  const date = new Date(input);\n  return date.toLocaleDateString(\"en-US\", {\n    month: \"long\",\n    day: \"numeric\",\n    year: \"numeric\",\n  });\n}\n\nexport function absoluteUrl(path: string) {\n  return `${process.env.NEXT_PUBLIC_APP_URL || \"https://nuvyxui.vercel.app\"}${path}`;\n}\n\nexport function constructMetadata({\n  title = \"Nuvyx UI - Modern React + Tailwind CSS + Motion components & Templates\",\n  description = \"Nuvyx UI is a curated collection of the best landing page components built using React + Tailwind CSS + Motion\",\n  image = absoluteUrl(\"/og\"),\n  ...props\n}: {\n  title?: string;\n  description?: string;\n  image?: string;\n  [key: string]: Metadata[keyof Metadata];\n}): Metadata {\n  return {\n    title,\n    description,\n    keywords: [\n      \"React\",\n      \"Tailwind CSS\",\n      \"Motion\",\n      \"Landing Page\",\n      \"Components\",\n      \"Next.js\",\n    ],\n    openGraph: {\n      title,\n      description,\n      type: \"website\",\n      images: [\n        {\n          url: image,\n          width: 1200,\n          height: 630,\n        },\n      ],\n    },\n    twitter: {\n      card: \"summary_large_image\",\n      title,\n      description,\n      images: [image],\n      creator: \"@mihirjaiswal\",\n    },\n    icons: \"/favicon.ico\",\n    metadataBase: new URL(\"https://nuvyxui.vercel.app/\"),\n    authors: [\n      {\n        name: \"Mihir Jaiswal\",\n        url: \"https://github.com/MihirJaiswal\",\n      },\n    ],\n    creator: \"mihirjaiswal\",\n    ...props,\n  };\n}\n",
      "type": "registry:lib",
      "target": ""
    }
  ]
}