{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "morphing-blob",
  "type": "registry:ui",
  "title": "Morphing Blob",
  "description": "A morphing blob that that provide several effects.",
  "dependencies": [
    "three",
    "@react-three/fiber",
    "@react-three/drei",
    "@react-three/postprocessing",
    "@react-three/fiber",
    "@react-three/postprocessing",
    "@react-three/drei",
    "three"
  ],
  "files": [
    {
      "path": "registry/ui/morphing-blob.tsx",
      "content": "\"use client\"\r\n\r\nimport type React from \"react\"\r\nimport { Canvas, useFrame, useThree } from \"@react-three/fiber\"\r\nimport { EffectComposer, Bloom, ChromaticAberration } from \"@react-three/postprocessing\"\r\nimport { Environment, Html } from \"@react-three/drei\"\r\nimport { useMemo, useRef, Suspense } from \"react\"\r\nimport * as THREE from \"three\"\r\n\r\n/* ----------------------------------------------------------------– */\r\n/* --------------------------  SHADERS  ---------------------------- */\r\n/* ----------------------------------------------------------------– */\r\n\r\nconst vertexShader = /* glsl */ `\r\n  uniform float uTime;\r\n  uniform float uComplexity;\r\n  uniform float uSpeed;\r\n  uniform vec2  uPointer;\r\n  uniform float uInfluence;\r\n\r\n  varying vec3 vNormal;\r\n  varying vec3 vPosition;\r\n  varying vec3 vWorldPosition;\r\n\r\n  /* Simplex noise helpers ........................................ */\r\n  vec3 mod289(vec3 x){return x-floor(x*(1./289.))*289.;}\r\n  vec4 mod289(vec4 x){return x-floor(x*(1./289.))*289.;}\r\n  vec4 permute(vec4 x){return mod289(((x*34.)+1.)*x);}\r\n  vec4 taylorInvSqrt(vec4 r){return 1.79284291400159-0.85373472095314*r;}\r\n\r\n  float snoise(vec3 v){\r\n    const vec2  C = vec2(1./6., 1./3.);\r\n    const vec4  D = vec4(0.,.5,1.,2.);\r\n\r\n    vec3 i = floor(v + dot(v, C.yyy));\r\n    vec3 x0 = v - i + dot(i, C.xxx);\r\n\r\n    vec3 g = step(x0.yzx, x0.xyz);\r\n    vec3 l = 1. - g;\r\n    vec3 i1 = min(g.xyz, l.zxy);\r\n    vec3 i2 = max(g.xyz, l.zxy);\r\n\r\n    vec3 x1 = x0 - i1 + C.xxx;\r\n    vec3 x2 = x0 - i2 + C.yyy;\r\n    vec3 x3 = x0 - D.yyy;\r\n\r\n    i = mod289(i);\r\n    vec4 p = permute( permute( permute(\r\n              i.z + vec4(0., i1.z, i2.z, 1.))\r\n            + i.y + vec4(0., i1.y, i2.y, 1.))\r\n            + i.x + vec4(0., i1.x, i2.x, 1.));\r\n\r\n    float n_ = 1./7.;\r\n    vec3  ns = n_ * D.wyz - D.xzx;\r\n\r\n    vec4 j = p - 49. * floor(p * ns.z * ns.z);\r\n    vec4 x_ = floor(j * ns.z);\r\n    vec4 y_ = floor(j - 7. * x_);\r\n\r\n    vec4 x = x_ * ns.x + ns.yyyy;\r\n    vec4 y = y_ * ns.x + ns.yyyy;\r\n    vec4 h = 1. - abs(x) - abs(y);\r\n\r\n    vec4 b0 = vec4(x.xy, y.xy);\r\n    vec4 b1 = vec4(x.zw, y.zw);\r\n\r\n    vec4 s0 = floor(b0)*2.+1.;\r\n    vec4 s1 = floor(b1)*2.+1.;\r\n    vec4 sh = -step(h, vec4(0.));\r\n\r\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\r\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\r\n\r\n    vec3 p0 = vec3(a0.xy,h.x);\r\n    vec3 p1 = vec3(a0.zw,h.y);\r\n    vec3 p2 = vec3(a1.xy,h.z);\r\n    vec3 p3 = vec3(a1.zw,h.w);\r\n\r\n    vec4 norm = taylorInvSqrt(vec4(\r\n      dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\r\n    p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3*=norm.w;\r\n\r\n    vec4 m = max(0.6 - vec4(\r\n      dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.);\r\n    m = m*m;\r\n    return 42. * dot(m*m, vec4(\r\n      dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\r\n  }\r\n\r\n  /* --------------------------------------------------------------- */\r\n\r\n  void main(){\r\n    vNormal = normal;\r\n    vPosition = position;\r\n    vec3 pos = position;\r\n\r\n    /* Enhanced noise layering for more dramatic morphing */\r\n    float n1 = snoise(pos*2.+uTime*uSpeed);\r\n    float n2 = snoise(pos*4.+uTime*uSpeed*1.5);\r\n    float n3 = snoise(pos*8.+uTime*uSpeed*0.8);\r\n    float n4 = snoise(pos*16.+uTime*uSpeed*0.3);\r\n    float disp = (n1*.4 + n2*.3 + n3*.2 + n4*.1)*uComplexity;\r\n\r\n    /* Enhanced pointer attraction */\r\n    vec3 world = (modelMatrix*vec4(pos,1.)).xyz;\r\n    float d = distance(world.xy, vec2(uPointer.x*8., uPointer.y*8.));\r\n    float influence = exp(-d*0.5)*uInfluence;\r\n\r\n    pos += normal * (disp + influence);\r\n    vWorldPosition = (modelMatrix * vec4(pos, 1.0)).xyz;\r\n\r\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos,1.);\r\n  }\r\n`\r\n\r\nconst fragmentShader = /* glsl */ `\r\n  uniform float uTime;\r\n  uniform vec3  uA;\r\n  uniform vec3  uB;\r\n  uniform vec3  uC;\r\n\r\n  varying vec3 vNormal;\r\n  varying vec3 vPosition;\r\n  varying vec3 vWorldPosition;\r\n\r\n  void main(){\r\n    // Calculate distance from center for circular masking\r\n    float dist = length(vPosition);\r\n    \r\n    // Create a smooth falloff to make edges transparent\r\n    float alpha = 1.0 - smoothstep(1.8, 2.2, dist);\r\n    \r\n    // Discard fragments that are too far from center\r\n    if(alpha < 0.01) discard;\r\n    \r\n    // Enhanced gradient calculation\r\n    float grad = vNormal.y*0.5 + 0.5;\r\n    \r\n    // Vibrant but stable time-based color mixing\r\n    float mix1 = sin(uTime*0.6+vPosition.x*3.+vPosition.z*2.)*0.4+0.6;\r\n    float mix2 = cos(uTime*0.4+vPosition.y*2.5+vPosition.z*3.)*0.4+0.6;\r\n    float mix3 = sin(uTime*0.3+vPosition.x*1.5+vPosition.y*2.)*0.3+0.7;\r\n    \r\n    // Keep vibrant range but prevent going too dark\r\n    grad = smoothstep(0.1, 0.9, grad);\r\n    mix1 = smoothstep(0.2, 1.0, mix1);\r\n    mix2 = smoothstep(0.2, 1.0, mix2);\r\n    mix3 = smoothstep(0.4, 1.0, mix3);\r\n    \r\n    // Vibrant color blending\r\n    vec3 col = mix(uA, uB, grad);\r\n    col = mix(col, uC, mix1 * mix2 * 0.6);\r\n    \r\n    // Add vibrant color variation\r\n    vec3 accent = mix(uB, uC, mix3);\r\n    col = mix(col, accent, 0.35);\r\n    \r\n    // Enhanced rim lighting\r\n    float rim = 1.0 - abs(dot(vNormal, vec3(0.0, 0.0, 1.0)));\r\n    rim = pow(rim, 1.5);\r\n    \r\n    // Boost saturation and vibrancy significantly - ENHANCED for transparency\r\n    col = mix(col, col * col, 0.6); // Increased saturation boost\r\n    col = pow(col, vec3(0.7)); // More aggressive gamma adjustment\r\n    \r\n    // Add vibrant rim lighting\r\n    vec3 rimColor = mix(uB, uC, 0.5);\r\n    col += rimColor * rim * 0.6; // Increased rim intensity\r\n    \r\n    // Boost overall brightness for transparent background\r\n    col *= 1.3; // Brightness multiplier\r\n    \r\n    // Final clamp to prevent overexposure but keep vibrancy\r\n    col = min(col, vec3(1.4)); // Slightly higher clamp\r\n    \r\n    // Apply the alpha for smooth edges\r\n    gl_FragColor = vec4(col, alpha * 0.95);\r\n  }\r\n`\r\n\r\n/* ----------------------------------------------------------------– */\r\n/* ----------------------  BLOB   MESH  ----------------------------- */\r\n/* ----------------------------------------------------------------– */\r\nfunction Blob({\r\n  theme,\r\n  complexity,\r\n  speed,\r\n}: {\r\n  theme: \"primary\" | \"aurora\" | \"cosmic\" | \"liquid\" | \"danger\"\r\n  complexity: number\r\n  speed: number\r\n}) {\r\n  const { pointer, clock } = useThree()\r\n  const mesh = useRef<THREE.Mesh>(null!)\r\n\r\n  // Much more vibrant color themes\r\n  const themes = {\r\n    primary: { a: \"#0A0F8A\", b: \"#1E40FF\", c: \"#00D4FF\" },\r\n    aurora: { a: \"#4A00FF\", b: \"#FF006B\", c: \"#00FFFF\" },\r\n    cosmic: { a: \"#B766EA\", b: \"#70209B\", c: \"#F093FB\" },\r\n    liquid: { a: \"#805AFC\", b: \"#04E9AD\", c: \"#FC8EED\" },\r\n    danger: { a: \"#FF0000\", b: \"#FF4000\", c: \"#FFAA00\" },\r\n  } as const\r\n\r\n  const { a, b, c } = themes[theme] ?? themes.aurora\r\n\r\n  const uniforms = useMemo(\r\n    () => ({\r\n      uTime: { value: 0 },\r\n      uComplexity: { value: complexity * 0.15 },\r\n      uSpeed: { value: speed * 0.25 },\r\n      uPointer: { value: new THREE.Vector2() },\r\n      uInfluence: { value: 0.6 },\r\n      uA: { value: new THREE.Color(a) },\r\n      uB: { value: new THREE.Color(b) },\r\n      uC: { value: new THREE.Color(c) },\r\n    }),\r\n    [a, b, c, complexity, speed],\r\n  )\r\n\r\n  useFrame(() => {\r\n    if (uniforms.uTime) {\r\n      uniforms.uTime.value = clock.elapsedTime\r\n    }\r\n    if (uniforms.uPointer && pointer) {\r\n      uniforms.uPointer.value.copy(pointer)\r\n    }\r\n  })\r\n\r\n  return (\r\n    <mesh ref={mesh}>\r\n      <icosahedronGeometry args={[2, 6]} />\r\n      <shaderMaterial\r\n        vertexShader={vertexShader}\r\n        fragmentShader={fragmentShader}\r\n        uniforms={uniforms}\r\n        transparent\r\n        alphaTest={0.01}\r\n        side={THREE.DoubleSide}\r\n      />\r\n    </mesh>\r\n  )\r\n}\r\n\r\n/* ----------------------------------------------------------------– */\r\n/* ----------------------  PARTICLES  ------------------------------- */\r\n/* ----------------------------------------------------------------– */\r\n\r\nfunction Particles({ count = 150, color = \"#00FFFF\" }) {\r\n  const points = useRef<THREE.Points>(null!)\r\n\r\n  const [positions, scales] = useMemo(() => {\r\n    const pos = new Float32Array(count * 3)\r\n    const scl = new Float32Array(count)\r\n    for (let i = 0; i < count; i++) {\r\n      const r = 4 + Math.random() * 3\r\n      const theta = Math.random() * Math.PI * 2\r\n      const phi = Math.acos(Math.random() * 2 - 1)\r\n      pos[i * 3] = r * Math.sin(phi) * Math.cos(theta)\r\n      pos[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta)\r\n      pos[i * 3 + 2] = r * Math.cos(phi)\r\n      scl[i] = Math.random() * 0.8 + 0.2\r\n    }\r\n    return [pos, scl]\r\n  }, [count])\r\n\r\n  const uniforms = useMemo(\r\n    () => ({\r\n      uTime: { value: 0 },\r\n      uSize: { value: 35 },\r\n      uColor: { value: new THREE.Color(color) },\r\n    }),\r\n    [color],\r\n  )\r\n\r\n  useFrame(({ clock }) => {\r\n    if (uniforms.uTime) {\r\n      uniforms.uTime.value = clock.elapsedTime\r\n    }\r\n  })\r\n\r\n  return (\r\n    <points ref={points}>\r\n      <bufferGeometry>\r\n        <bufferAttribute \r\n          attach=\"attributes-position\" \r\n          args={[positions, 3]}\r\n        />\r\n        <bufferAttribute \r\n          attach=\"attributes-scale\" \r\n          args={[scales, 1]}\r\n        />\r\n      </bufferGeometry>\r\n      <shaderMaterial\r\n        vertexShader={\r\n          /* glsl */ `\r\n          uniform float uTime;\r\n          uniform float uSize;\r\n          attribute float scale;\r\n          void main(){\r\n            vec3 pos = position;\r\n            pos.x += sin(uTime * 0.4 + pos.y * 0.3) * 0.3;\r\n            pos.y += cos(uTime * 0.3 + pos.x * 0.3) * 0.3;\r\n            pos.z += sin(uTime * 0.2 + pos.x * 0.2) * 0.2;\r\n            vec4 mvPos = modelViewMatrix * vec4(pos, 1.0);\r\n            gl_Position = projectionMatrix * mvPos;\r\n            gl_PointSize = uSize * scale * (1.0 / -mvPos.z);\r\n          }\r\n        `\r\n        }\r\n        fragmentShader={\r\n          /* glsl */ `\r\n          uniform vec3 uColor;\r\n          void main(){\r\n            float d = distance(gl_PointCoord, vec2(0.5));\r\n            if(d > 0.5) discard;\r\n            float alpha = 1.0 - (d * 2.0);\r\n            alpha = pow(alpha, 2.0) * 0.9; // Slightly brighter particles\r\n            gl_FragColor = vec4(uColor, alpha);\r\n          }\r\n        `\r\n        }\r\n        uniforms={uniforms}\r\n        blending={THREE.AdditiveBlending}\r\n        depthWrite={false}\r\n        transparent\r\n      />\r\n    </points>\r\n  )\r\n}\r\n\r\n/* ----------------------------------------------------------------– */\r\n/* ----------------------  SCENE  ---------------------------------- */\r\n/* ----------------------------------------------------------------– */\r\n\r\nfunction Scene({\r\n  theme = \"aurora\",\r\n  complexity = 3,\r\n  speed = 3,\r\n  particleCount = 150,\r\n}: {\r\n  theme?: \"primary\" | \"aurora\" | \"cosmic\" | \"liquid\" | \"danger\"\r\n  complexity?: number\r\n  speed?: number\r\n  particleCount?: number\r\n}) {\r\n  const particleColors = {\r\n    primary: \"#00D4FF\",\r\n    aurora: \"#00FFD4\",\r\n    cosmic: \"#FF006B\",\r\n    liquid: \"#00FFAA\",\r\n    danger: \"#FFAA00\",\r\n  }\r\n\r\n  return (\r\n    <>\r\n      <Blob theme={theme} complexity={complexity!} speed={speed!} />\r\n      <Particles count={particleCount} color={particleColors[theme]} />\r\n\r\n      <ambientLight intensity={0.3} /> {/* Increased ambient light */}\r\n      <pointLight position={[10, 10, 10]} intensity={1.5} color=\"#ffffff\" /> {/* Increased intensity */}\r\n      <pointLight position={[-10, -10, -10]} intensity={1.0} color=\"#4444ff\" /> {/* Increased intensity */}\r\n      <Environment preset=\"night\" />\r\n\r\n      {/* Optimized post-processing for transparent background */}\r\n      <EffectComposer>\r\n        <Bloom \r\n          intensity={1.5} // Increased bloom intensity\r\n          luminanceThreshold={0.02} // Lower threshold for more bloom\r\n          luminanceSmoothing={0.8}\r\n        />\r\n        <ChromaticAberration offset={[0.002, 0.002]} />\r\n      </EffectComposer>\r\n    </>\r\n  )\r\n}\r\n\r\n/* ----------------------------------------------------------------– */\r\n/* ----------------------  LOADING  -------------------------------- */\r\n/* ----------------------------------------------------------------– */\r\n\r\nfunction LoadingFallback() {\r\n  return (\r\n    <div style={{\r\n      width: '100%',\r\n      height: '100%',\r\n      display: 'flex',\r\n      alignItems: 'center',\r\n      justifyContent: 'center',\r\n      background: 'transparent',\r\n      color: '#ffffff',\r\n      fontSize: '18px',\r\n      fontWeight: 'bold'\r\n    }}>\r\n      Loading...\r\n    </div>\r\n  )\r\n}\r\n\r\n/* ----------------------------------------------------------------– */\r\n/* --------------------  EXPORTED  COMPONENT  ----------------------- */\r\n/* ----------------------------------------------------------------– */\r\n\r\nexport function MorphingBlob({\r\n  size = 400,\r\n  theme = \"aurora\",\r\n  complexity = 3,\r\n  speed = 3,\r\n  particleCount = 150,\r\n  enableEffects = true,\r\n  children,\r\n  className,\r\n  mouseTracking,\r\n  ...rest\r\n}: {\r\n  size?: number\r\n  theme?: \"primary\" | \"aurora\" | \"cosmic\" | \"liquid\" | \"danger\"\r\n  complexity?: number\r\n  speed?: number\r\n  particleCount?: number\r\n  enableEffects?: boolean\r\n  children?: React.ReactNode\r\n  className?: string\r\n  mouseTracking?: boolean\r\n} & React.HTMLAttributes<HTMLDivElement>) {\r\n  return (\r\n    <div \r\n      className={className} \r\n      style={{ \r\n        width: size, \r\n        height: size, \r\n        position: 'relative',\r\n        display: 'flex',\r\n        alignItems: 'center',\r\n        justifyContent: 'center'\r\n      }} \r\n      {...rest}\r\n    >\r\n      {/* 3D Canvas - positioned absolutely to avoid layout issues */}\r\n      <div style={{\r\n        position: 'absolute',\r\n        top: 0,\r\n        left: 0,\r\n        width: '100%',\r\n        height: '100%',\r\n        zIndex: 1\r\n      }}>\r\n        <Suspense fallback={<LoadingFallback />}>\r\n          <Canvas \r\n            camera={{ position: [0, 0, 8], fov: 45 }} \r\n            gl={{ \r\n              antialias: true, \r\n              alpha: true,\r\n              powerPreference: \"high-performance\",\r\n              premultipliedAlpha: false,\r\n              preserveDrawingBuffer: false\r\n            }}\r\n            dpr={[1, 2]}\r\n            style={{ \r\n              background: 'transparent',\r\n              width: '100%',\r\n              height: '100%'\r\n            }}\r\n            onCreated={({ gl }) => {\r\n              gl.toneMapping = THREE.ACESFilmicToneMapping\r\n              gl.toneMappingExposure = 1.5 // Increased exposure for brightness\r\n              gl.setClearColor(0x000000, 0) // Fully transparent background\r\n            }}\r\n          >\r\n            <Scene \r\n              theme={theme} \r\n              complexity={complexity} \r\n              speed={speed} \r\n              particleCount={particleCount}\r\n            />\r\n          </Canvas>\r\n        </Suspense>\r\n      </div>\r\n\r\n      {/* Children content - positioned absolutely on top */}\r\n      {children && (\r\n        <div style={{\r\n          position: 'absolute',\r\n          top: '50%',\r\n          left: '50%',\r\n          transform: 'translate(-50%, -50%)',\r\n          zIndex: 2,\r\n          pointerEvents: 'auto'\r\n        }}>\r\n          {children}\r\n        </div>\r\n      )}\r\n    </div>\r\n  )\r\n}\r\n\r\n// Demo component\r\nexport default function Demo() {\r\n  return (\r\n    <div style={{ \r\n      background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',\r\n      minHeight: '100vh',\r\n      display: 'flex',\r\n      alignItems: 'center',\r\n      justifyContent: 'center',\r\n      padding: '20px'\r\n    }}>\r\n      <MorphingBlob \r\n        size={400}\r\n        theme=\"aurora\"\r\n        complexity={4}\r\n        speed={2}\r\n        particleCount={200}\r\n      >\r\n        <div style={{\r\n          background: 'rgba(255, 255, 255, 0.1)',\r\n          backdropFilter: 'blur(10px)',\r\n          borderRadius: '20px',\r\n          padding: '20px',\r\n          color: 'white',\r\n          textAlign: 'center'\r\n        }}>\r\n          <h2 style={{ margin: 0, fontSize: '24px' }}>Bright Blob</h2>\r\n          <p style={{ margin: '10px 0 0 0', opacity: 0.8 }}>\r\n            Transparent background, vibrant colors\r\n          </p>\r\n        </div>\r\n      </MorphingBlob>\r\n    </div>\r\n  )\r\n}",
      "type": "registry:ui",
      "target": "components/ui/morphing-blob.tsx"
    }
  ]
}