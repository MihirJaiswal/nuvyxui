import { exec } from "child_process";
import { promises as fs } from "fs";
import path from "path";
import { registryItemSchema, type Registry } from "shadcn/registry";
import { z } from "zod";

import { examples } from "../../registry/registry-examples";
import { lib } from "../../registry/registry-lib";
import { ui } from "../../registry/registry-ui";

const DEPRECATED_ITEMS = ["toast"];

// Utility to execute commands with output streaming
function executeCommand(command: string): Promise<{ stdout: string; stderr: string; code: number }> {
  return new Promise((resolve) => {
    console.log(`Running command: ${command}`);
    const proc = exec(command);
    
    let stdout = '';
    let stderr = '';
    
    proc.stdout?.on('data', (data) => {
      stdout += data.toString();
      process.stdout.write(data);
    });
    
    proc.stderr?.on('data', (data) => {
      stderr += data.toString();
      process.stderr.write(data);
    });
    
    proc.on('exit', (code) => {
      resolve({ stdout, stderr, code: code || 0 });
    });
  });
}

// File exists utility
async function fileExists(filePath: string): Promise<boolean> {
  try {
    await fs.access(filePath);
    return true;
  } catch {
    return false;
  }
}

const registry = {
  name: "shadcn/ui",
  homepage: "https://ui.shadcn.com",
  items: z.array(registryItemSchema).parse(
    [
      {
        name: "index",
        type: "registry:style",
        dependencies: [
          "tw-animate-css",
          "class-variance-authority",
          "lucide-react",
        ],
        registryDependencies: ["utils"],
        cssVars: {},
        files: [],
      },
      ...ui,
      ...examples,
      ...lib,
    ].filter((item) => {
      return !DEPRECATED_ITEMS.includes(item.name);
    }),
  ),
} satisfies Registry;

function getRelativeImportPath(filePath) {
  if (!filePath) return "";
  
  // For utils specifically (special case handling)
  if (filePath.includes("src/lib/utils")) {
    return "../src/lib/utils";
  }
  
  // For nuvyxui components
  if (filePath.includes("src/nuvyxui/")) {
    return "../" + filePath;
  }
  
  // Default case
  return "../" + filePath;
}

async function buildRegistryIndex() {
  let index = `/* eslint-disable @typescript-eslint/ban-ts-comment */
/* eslint-disable @typescript-eslint/no-explicit-any */
// @ts-nocheck
// This file is autogenerated by scripts/build-registry.ts
// Do not edit this file directly.
import * as React from "react"

export const Index: Record<string, any> = {`;
  for (const item of registry.items) {
    const resolveFiles = item.files?.map((file) => `${file.path}`);
    if (!resolveFiles) {
      continue;
    }

    // Get the component path using our helper function
    const filePath = item.files?.[0]?.path || "";
    const componentPath = getRelativeImportPath(filePath);

    index += `
  "${item.name}": {
    name: "${item.name}",
    description: "${item.description ?? ""}",
    type: "${item.type}",
    registryDependencies: ${JSON.stringify(item.registryDependencies || [])},
    files: [${item.files?.map((file) => {
      const filePath = `${typeof file === "string" ? file : file.path}`;
      const resolvedFilePath = path.resolve(filePath);
      return typeof file === "string"
        ? `"${resolvedFilePath}"`
        : `{
      path: "${filePath}",
      type: "${file.type || ''}",
      target: "${file.target || ''}"
    }`;
    })}],
    component: ${
      componentPath
        ? `React.lazy(async () => {
      try {
        const mod = await import("${componentPath}")
        const exportName = Object.keys(mod).find(key => typeof mod[key] === 'function' || typeof mod[key] === 'object') || "${item.name}"
        return { default: mod.default || mod[exportName] }
      } catch (error) {
        console.error("Error loading component ${item.name}:", error)
        return { default: () => React.createElement("div", {}, "Failed to load component") }
      }
    })`
        : "null"
    },
    meta: ${JSON.stringify(item.meta || {})},
  },`;
  }

  index += `
  }`;

  // Create __registry__ directory if it doesn't exist
  const registryDir = path.join(process.cwd(), "__registry__");
  await fs.mkdir(registryDir, { recursive: true });

  // Write style index.
  const indexPath = path.join(process.cwd(), "__registry__/index.tsx");
  if (await fileExists(indexPath)) {
    await fs.unlink(indexPath);
  }
  await fs.writeFile(indexPath, index);
}

async function buildRegistryJsonFile() {
  // 1. Fix the path for registry items.
  const fixedRegistry = {
    ...registry,
    items: registry.items.map((item) => {
      const files = item.files?.map((file) => {
        return {
          ...file,
          path: `${file.path}`,
        };
      });

      return {
        ...item,
        files,
      };
    }),
  };

  // 2. Write the content of the registry to `registry.json` and public folder
  const registryJsonPath = path.join(process.cwd(), `registry.json`);
  if (await fileExists(registryJsonPath)) {
    await fs.unlink(registryJsonPath);
  }
  
  const publicRegistryPath = path.join(process.cwd(), `public/registry.json`);
  if (await fileExists(publicRegistryPath)) {
    await fs.unlink(publicRegistryPath);
  }

  const registryJson = JSON.stringify(fixedRegistry, null, 2);

  await fs.writeFile(registryJsonPath, registryJson);
  
  // Ensure public directory exists
  const publicDir = path.join(process.cwd(), `public`);
  await fs.mkdir(publicDir, { recursive: true });
  
  await fs.writeFile(publicRegistryPath, registryJson);
}

async function buildRegistry() {
  console.log("Executing registry build with verbose output...");
  try {
    const result = await executeCommand(`npx shadcn registry:build --verbose`);
    if (result.code !== 0) {
      throw new Error(`Process exited with code ${result.code}`);
    }
    return result;
  } catch (error) {
    console.error("Error executing registry build:", error);
    throw error;
  }
}

async function main() {
  try {
    console.log("üóÇÔ∏è Building registry/__index__.tsx...");
    await buildRegistryIndex();
    console.log("‚úÖ Registry index built successfully");

    console.log("üíÖ Building registry.json...");
    await buildRegistryJsonFile();
    console.log("‚úÖ Registry JSON file built successfully");

    console.log("üèóÔ∏è Building registry...");
    await buildRegistry();
    console.log("‚úÖ Registry build completed");
  } catch (error) {
    console.error("‚ùå Build failed with error:");
    console.error(error);
    if (error instanceof Error) {
      console.error("Error stack:", error.stack);
    }
    process.exit(1);
  }
}

main();